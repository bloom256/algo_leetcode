<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>chapter_6_binary_tree</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="style.css" />
  <base href="/algo_leetcode/">
</head>
<body>
<h2 id="binary-tree">Binary Tree</h2>
<h3 id="dfs">DFS</h3>
<h4 id="maximum-depth-of-binary-tree">Maximum Depth of Binary Tree</h4>
<ul>
<li><strong>Recursive DFS:</strong> The depth of a node is
<code>1 + max(left_depth, right_depth)</code>. The base case is a null
node, which has a depth of 0. Time: O(N), where N is the number of
nodes, as we visit each node once. Space: O(H), where H is the height of
the tree, due to the recursion stack. In the worst case (a skewed tree),
this can be O(N).</li>
<li><strong>Iterative DFS:</strong> Use a stack to store pairs of
<code>(node, depth)</code>. Start with the root and a depth of 1. While
the stack is not empty, pop a node, update the maximum depth found so
far, and push its children with an incremented depth. Time: O(N). Space:
O(H), for the stack.</li>
</ul>
<h4 id="invert-binary-tree">Invert Binary Tree</h4>
<ul>
<li><strong>Recursive DFS:</strong> For each node, swap its left and
right children, then recursively call the function for the left and
right children. The base case is a null node. Time: O(N), Space:
O(H).</li>
<li><strong>Iterative DFS:</strong> Use a stack. Push the root. While
the stack is not empty, pop a node, swap its children, then push the new
right and left children if they exist. Time: O(N), Space: O(H).</li>
</ul>
<h4 id="same-tree">Same Tree</h4>
<ul>
<li><strong>Iterative DFS:</strong> Use two stacks, one for each tree.
Push the roots onto their respective stacks. While both stacks are not
empty, pop a node from each. If one node is null and the other isn’t, or
if their values are different, the trees are not the same. Then, push
the left and right children of both nodes onto their stacks. If the
stacks are both empty at the end, the trees are the same. Time: O(N),
Space: O(H).</li>
</ul>
<h4 id="symmetric-tree">Symmetric Tree</h4>
<ul>
<li><strong>Iterative DFS with Two Stacks:</strong> Use two stacks. Push
the root onto both stacks. While the stacks are not empty, pop a node
from each. If one node is null and the other isn’t, or if their values
are different, the tree is not symmetric. For the first stack, push the
left then the right child. For the second stack, push the right then the
left child. If the stacks are both empty at the end, the tree is
symmetric. Time: O(N), Space: O(H).</li>
</ul>
<h4 id="path-sum">Path Sum</h4>
<ul>
<li><strong>Description:</strong> Iterative DFS. Use a
<code>std::vector</code> as a stack to store pairs of
<code>(node, prev_sum)</code>. A leaf is a node where both its left and
right children are null. In each iteration, calculate
<code>curr_sum = prev_sum + node-&gt;val</code>. If the current node is
a leaf, compare <code>curr_sum</code> to the <code>targetSum</code>. If
they are equal, a path is found. If the loop finishes without finding a
path, return false.</li>
<li><strong>Time Complexity:</strong> O(N), as each node is visited
once.</li>
<li><strong>Space Complexity:</strong> O(H) in a balanced tree, where H
is the height. In the worst case of a skewed tree, this can be
O(N).</li>
</ul>
<h3 id="bst">BST</h3>
<h4 id="search-in-a-binary-search-tree">Search in a Binary Search
Tree</h4>
<ul>
<li><strong>Description:</strong> Start at the root. While the current
node is not null, compare its value with the target. If they match,
return the node. If the target is smaller, move to the left child;
otherwise, move to the right child. If the loop finishes, the value is
not in the tree.</li>
<li><strong>Time Complexity:</strong> O(H), where H is the height of the
tree. For a balanced tree, this is O(log N). In the worst case of a
skewed tree, it’s O(N).</li>
<li><strong>Space Complexity:</strong> O(1) for the iterative
approach.</li>
</ul>
<h4 id="insert-into-a-binary-search-tree">Insert into a Binary Search
Tree</h4>
<ul>
<li><strong>Description:</strong> If the root is null, create a new node
and return it. Otherwise, start with <code>curr = root</code>. Loop as
long as <code>curr</code> is not null. If the new value is less than
<code>curr</code>’s value, check if <code>curr</code>’s left child is
null. If it is, insert the new node there and break the loop. Otherwise,
move to the left child. If the new value is greater than
<code>curr</code>’s value, check if the right child is null. If it is,
insert the new node there and break. Otherwise, move to the right child.
Return the original root.</li>
<li><strong>Time Complexity:</strong> O(H), where H is the height of the
tree. For a balanced tree, this is O(log N). In the worst case of a
skewed tree, it’s O(N).</li>
<li><strong>Space Complexity:</strong> O(1) for the iterative
approach.</li>
</ul>
<h4 id="validate-binary-search-tree">Validate Binary Search Tree</h4>
<ul>
<li><strong>Description (Iterative DFS with bounds):</strong> Use an
iterative DFS approach with a stack. The stack stores tuples of
<code>(node, min_val, max_val)</code>. Start by pushing the root onto
the stack with negative and positive infinity as the initial min and max
bounds. While the stack is not empty, pop a node. If the node is null,
continue. Check if the node’s value is outside its valid range
(<code>&lt;= min</code> or <code>&gt;= max</code>); if so, the tree is
invalid. Then, push the left child onto the stack with an updated max
bound of the current node’s value, and push the right child with an
updated min bound of the current node’s value. If the loop completes,
the tree is a valid BST.</li>
<li><strong>Description (In-order Traversal):</strong> An in-order DFS
traversal of a valid BST visits nodes in sorted order. Use a recursive
in-order helper function that keeps track of the previously visited
node’s value (<code>prev</code>). To enable early termination, the
helper function must return a boolean. The logic is: 1) Recurse on the
left subtree. If it returns <code>false</code>, propagate
<code>false</code> up. 2) Check if the current node’s value is less than
or equal to <code>prev</code>. If so, return <code>false</code>. 3)
Update <code>prev</code> and recurse on the right subtree.</li>
<li><strong>Time Complexity:</strong> O(N), as we visit each node
once.</li>
<li><strong>Space Complexity:</strong> O(H) for both the iterative stack
and the recursive in-order traversal stack, where H is the height of the
tree.</li>
</ul>
<h4 id="balanced-binary-tree">Balanced Binary Tree</h4>
<ul>
<li><strong>Description:</strong> Use post-order DFS to check if a
binary tree is balanced. Implement a recursive helper function
<code>checkHeight(node)</code> that returns the height of the subtree
rooted at <code>node</code> if it’s balanced, or -1 if it’s unbalanced.
The base case is a null node, which has a height of 0. For a non-null
node, recursively call <code>checkHeight</code> on its left and right
children. If either call returns -1, or if the absolute difference
between the left and right heights is greater than 1, return -1
(unbalanced). Otherwise, return
<code>1 + max(left_height, right_height)</code>. The main function calls
<code>checkHeight(root)</code> and returns <code>true</code> if the
result is not -1, <code>false</code> otherwise.</li>
<li><strong>Time Complexity:</strong> O(N), as each node is visited
once.</li>
<li><strong>Space Complexity:</strong> O(H), where H is the height of
the tree, due to the recursion stack.</li>
</ul>
<h3 id="bfs">BFS</h3>
<h4 id="binary-tree-level-order-traversal">Binary Tree Level Order
Traversal</h4>
<ul>
<li><strong>Description:</strong> Use a <code>std::deque</code> for a
breadth-first search (BFS). Start by pushing the root node into the
deque. While the deque is not empty, get the number of nodes at the
current level. Iterate that many times, processing each node: pop it
from the front, add its value to the current level’s results, and push
its non-null children to the back of the deque. After the inner loop,
add the current level’s results to the final answer.</li>
<li><strong>Time Complexity:</strong> O(N), as each node is visited
once.</li>
<li><strong>Space Complexity:</strong> O(W), where W is the maximum
width of the tree. In the worst case (a complete binary tree), the last
level can contain up to N/2 nodes, so space is O(N).</li>
</ul>
<h4 id="find-largest-value-in-each-tree-row">Find Largest Value in Each
Tree Row</h4>
<ul>
<li><strong>Description:</strong> Use BFS with a
<code>std::deque</code>. In each level of the traversal, keep track of
the maximum value seen so far. After iterating through all nodes at a
level, add the maximum value for that level to the result vector.</li>
<li><strong>Time Complexity:</strong> O(N), as each node is visited
once.</li>
<li><strong>Space Complexity:</strong> O(W), where W is the maximum
width of the tree.</li>
</ul>
</body>
</html>

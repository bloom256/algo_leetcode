<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>chapter_8_heap</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="style.css" />
  <base href="/algo_leetcode/">
</head>
<body>
<h2 id="heap">Heap</h2>
<h4 id="kth-largest-element-in-an-array">Kth Largest Element in an
Array</h4>
<ul>
<li><strong>Task:</strong> <em>Given an integer array nums and an
integer k, return the kth largest element in the array. Note that it is
the kth largest element in the sorted order, not the kth distinct
element.</em></li>
<li><strong>Task summary:</strong> Find the k-th largest element in an
unsorted array.</li>
<li><strong>Solution 1:</strong>
<code>std::nth_element(nums.begin(), nums.begin() + nums.size() - k, nums.end())</code>
- best solution.</li>
<li><strong>Time complexity:</strong> O(N) average, O(N^2) worst
case.</li>
<li><strong>Space complexity:</strong> O(1).</li>
<li><strong>Solution 2:</strong> Run <code>std::make_heap</code> on
input array - to make it max heap. Then K-1 times do
<code>std::pop_heap(nums.begin(), nums.end() - i)</code> (notice -i).
After this the first element will be K largest.</li>
<li><strong>Time complexity:</strong> O(N + K log N).</li>
<li><strong>Space complexity:</strong> O(1).</li>
<li><strong>Solution 3:</strong> Create
<code>std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt; minPriorityQueue</code>
- empty minHeap. Then iterate over all elements in input array, push
them to heap. If heap grows larger than k elements, pop min element from
it. In the end the first element in heap will be K largest. This
solution is good if we don’t want to change input array.</li>
<li><strong>Time complexity:</strong> O(N log K).</li>
<li><strong>Space complexity:</strong> O(K).</li>
</ul>
<h4 id="kth-largest-element-in-a-stream">Kth Largest Element in a
Stream</h4>
<ul>
<li><strong>Task:</strong> <em>Design a class to find the kth largest
element in a stream. Note that it is the kth largest element in the
sorted order, not the kth distinct element. Implement KthLargest class:
<code>KthLargest(int k, int[] nums)</code> Initializes the object with
the integer k and the stream of integers nums.
<code>int add(int val)</code> Appends the integer val to the stream and
returns the element representing the kth largest element in the
stream.</em></li>
<li><strong>Task summary:</strong> Find the k-th largest element in a
data stream.</li>
<li><strong>Solution:</strong> Use
<code>std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt; minHeap;</code>
as a min-heap. In the constructor, iterate through the initial numbers
and push them to the heap, while maintaining a heap size of at most
<code>k</code>. In the <code>add</code> method, push the new value. If
the heap size exceeds <code>k</code>, pop the smallest element. The top
element of the heap is always the k-th largest.</li>
<li><strong>Time complexity:</strong> O(N log K) for constructor, O(log
K) for <code>add</code>, where N is the initial number of elements and K
is the given parameter.</li>
<li><strong>Space complexity:</strong> O(K) to store the heap.</li>
</ul>
<h4 id="top-k-frequent-elements">Top K Frequent Elements</h4>
<ul>
<li><strong>Task:</strong> <em>Given an integer array nums and an
integer k, return the k most frequent elements. You may return the
answer in any order.</em></li>
<li><strong>Task summary:</strong> Find the k most frequent elements in
an array.</li>
<li><strong>Solution:</strong> Use
<code>std::unordered_map&lt;int, int&gt; counts</code> to count the
frequency of each element. Then, create a min-heap of pairs
(<code>std::vector&lt;std::pair&lt;int, int&gt;&gt; minHeap</code>).
Iterate through the map and push pairs of
<code>{frequency, number}</code> into the heap using
<code>std::push_heap</code>. If the heap size exceeds <code>k</code>,
remove the smallest element using <code>std::pop_heap</code>. A custom
comparator <code>cmpGreater</code> for pairs is needed to make the
min-heap work correctly. Finally, the heap will contain the k most
frequent elements.</li>
<li><strong>Time complexity:</strong> O(N log K), where N is the number
of elements in the input array.</li>
<li><strong>Space complexity:</strong> O(N) in the worst case for the
hash map, and O(K) for the heap.</li>
</ul>
<h4 id="last-stone-weight">Last Stone Weight</h4>
<ul>
<li><strong>Task:</strong> <em>You are given an array of integers stones
where stones[i] is the weight of the ith stone. We are playing a game
with the stones. On each turn, we choose the two heaviest stones and
smash them together. Suppose the heaviest stones have weights x and y
with x &lt;= y. The result of this smash is: If x == y, both stones are
destroyed. If x != y, the stone of weight x is destroyed, and the stone
of weight y has new weight y - x. At the end of the game, there is at
most one stone left. Return the weight of the last remaining stone, or 0
if no stones are left.</em></li>
<li><strong>Task summary:</strong> In each step, we take two heaviest
stones, smash them, and put the resulting stone back. We need to find
the weight of the last stone.</li>
<li><strong>Solution:</strong> Use a max-heap
(<code>std::priority_queue&lt;int&gt; maxHeap</code>) to efficiently
find the two heaviest stones. Push all stone weights into the max-heap.
While the heap has more than one stone, pop the two largest stones,
calculate the difference, and if the difference is not zero, push it
back to the heap. The final result is the last remaining stone’s weight
or 0 if the heap is empty. If we can change input array, use
<code>std::make_heap</code> (O(N)) and <code>std::pop_heap</code>
(O(logN)) and <code>std::push_heap</code> (O(logN)) to work with it
directly.</li>
<li><strong>Time complexity:</strong> O(N log N) due to pushing N
elements to the heap.</li>
<li><strong>Space complexity:</strong> O(N) for the heap, or O(1) if we
modify the input array.</li>
</ul>
<h4 id="ipo">IPO</h4>
<ul>
<li><strong>Task:</strong> <em>Given n projects, where the i-th project
has a pure profit profits[i] and a minimum capital capital[i] required
to start it. Initially, you have w capital. When you finish a project,
you will obtain its pure profit. You can only start a project if you
have at least the capital required for it. At most, you can choose k
projects to finish. Your goal is to find the maximum final capital you
can achieve.</em></li>
<li><strong>Task summary:</strong> Maximize capital by selecting at most
k projects, given initial capital, project profits, and required
capital.</li>
<li><strong>Solution:</strong> Create
<code>std::vector&lt;std::pair&lt;int, int&gt;&gt; projects</code>
storing <code>{capital, profit}</code> pairs. Sort this vector by
capital. Initialize <code>maxHeap</code> (a
<code>std::priority_queue&lt;int&gt;</code>) for profits of affordable
projects and <code>projectIdx = 0</code>. Iterate <code>k</code> times:
in each iteration, add all projects whose capital requirement is met by
<code>currCapital</code> to <code>maxHeap</code>. If
<code>maxHeap</code> is empty, break (no more affordable projects).
Otherwise, add the top profit from <code>maxHeap</code> to
<code>currCapital</code> and remove it from <code>maxHeap</code>. Return
<code>currCapital</code>.</li>
<li><strong>Time complexity:</strong> O(N log N + K log N), where N is
the number of projects and K is the number of projects to choose.
Sorting takes O(N log N). In the loop, each project is added to the heap
once (O(N log N) total), and K times we extract max (O(K log N)).</li>
<li><strong>Space complexity:</strong> O(N) for storing projects and the
heap.</li>
</ul>
</body>
</html>

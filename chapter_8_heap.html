<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>chapter_8_heap</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="style.css" />
  <base href="/algo_leetcode/">
</head>
<body>
<h2 id="heap">Heap</h2>
<h4 id="kth-largest-element-in-an-array">Kth Largest Element in an
Array</h4>
<ul>
<li><em>Given an integer array nums and an integer k, return the kth
largest element in the array. Note that it is the kth largest element in
the sorted order, not the kth distinct element.</em></li>
<li>Find the k-th largest element in an unsorted array.</li>
<li><strong>Solution 1:</strong>
<code>std::nth_element(nums.begin(), nums.begin() + nums.size() - k, nums.end())</code>
- best solution.
<ul>
<li>Time complexity: O(N) average, O(N^2) worst case.</li>
<li>Space complexity: O(1).</li>
</ul></li>
<li><strong>Solution 2:</strong> Run <code>std::make_heap</code> on
input array - to make it max heap. Then K-1 times do
<code>std::pop_heap(nums.begin(), nums.end() - i)</code> (notice -i).
After this the first element will be K largest.
<ul>
<li>Time complexity: O(N) for <code>make_heap</code>, O(K log N) for K-1
<code>pop_heap</code> operations. Total: O(N + K log N).</li>
<li>Space complexity: O(1).</li>
</ul></li>
<li><strong>Solution 3:</strong> Create
<code>std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt; minPriorityQueue</code>
- empty minHeap. Then iterate over all elements in input array, push
them to heap. If heap grows larger than k elements, pop min element from
it. In the end the first element in heap will be K largest. This
solution is good if we donâ€™t want to change input array.
<ul>
<li>Time complexity: O(N log K).</li>
<li>Space complexity: O(K).</li>
</ul></li>
</ul>
</body>
</html>

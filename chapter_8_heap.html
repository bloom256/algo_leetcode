<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>chapter_8_heap</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="style.css" />
  <base href="/algo_leetcode/">
</head>
<body>
<h2 id="heap">Heap</h2>
<h4 id="kth-largest-element-in-an-array">Kth Largest Element in an
Array</h4>
<ul>
<li><strong>Task:</strong> <em>Given an integer array nums and an
integer k, return the kth largest element in the array. Note that it is
the kth largest element in the sorted order, not the kth distinct
element.</em></li>
<li><strong>Task summary:</strong> Find the k-th largest element in an
unsorted array.</li>
<li><strong>Solution 1:</strong>
<code>std::nth_element(nums.begin(), nums.begin() + nums.size() - k, nums.end())</code>
- best solution.</li>
<li><strong>Time complexity:</strong> O(N) average, O(N^2) worst
case.</li>
<li><strong>Space complexity:</strong> O(1).</li>
<li><strong>Solution 2:</strong> Run <code>std::make_heap</code> on
input array - to make it max heap. Then K-1 times do
<code>std::pop_heap(nums.begin(), nums.end() - i)</code> (notice -i).
After this the first element will be K largest.</li>
<li><strong>Time complexity:</strong> O(N + K log N).</li>
<li><strong>Space complexity:</strong> O(1).</li>
<li><strong>Solution 3:</strong> Create
<code>std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt; minPriorityQueue</code>
- empty minHeap. Then iterate over all elements in input array, push
them to heap. If heap grows larger than k elements, pop min element from
it. In the end the first element in heap will be K largest. This
solution is good if we donâ€™t want to change input array.</li>
<li><strong>Time complexity:</strong> O(N log K).</li>
<li><strong>Space complexity:</strong> O(K).</li>
</ul>
<h4 id="kth-largest-element-in-a-stream">Kth Largest Element in a
Stream</h4>
<ul>
<li><strong>Task:</strong> <em>Design a class to find the kth largest
element in a stream. Note that it is the kth largest element in the
sorted order, not the kth distinct element. Implement KthLargest class:
<code>KthLargest(int k, int[] nums)</code> Initializes the object with
the integer k and the stream of integers nums.
<code>int add(int val)</code> Appends the integer val to the stream and
returns the element representing the kth largest element in the
stream.</em></li>
<li><strong>Task summary:</strong> Find the k-th largest element in a
data stream.</li>
<li><strong>Solution:</strong> Use
<code>std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt; minHeap;</code>
as a min-heap. In the constructor, iterate through the initial numbers
and push them to the heap, while maintaining a heap size of at most
<code>k</code>. In the <code>add</code> method, push the new value. If
the heap size exceeds <code>k</code>, pop the smallest element. The top
element of the heap is always the k-th largest.</li>
<li><strong>Time complexity:</strong> O(N log K) for constructor, O(log
K) for <code>add</code>, where N is the initial number of elements and K
is the given parameter.</li>
<li><strong>Space complexity:</strong> O(K) to store the heap.</li>
</ul>
</body>
</html>

<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>chapter_5_stack_queue</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="style.css" />
  <base href="/algo_leetcode/">
</head>
<body>
<h2 id="stackqueue">Stack/Queue</h2>
<h4 id="valid-parentheses">Valid Parentheses</h4>
<ul>
<li><em>Given a string s containing just the characters ‘(’, ‘)’, ‘{’,
‘}’, ‘[’ and ’]’, determine if the input string is valid. An input
string is valid if: Open brackets must be closed by the same type of
brackets. Open brackets must be closed in the correct order. Every close
bracket has a corresponding open bracket of the same type.</em></li>
<li><strong>Stack-based:</strong> Use a <code>std::stack</code>. For an
opening bracket, push it onto the stack. For a closing bracket, if the
stack is empty or its top doesn’t match, the string is invalid;
otherwise, pop the stack. The string is valid if the stack is empty
after the loop. Time: O(N), Space: O(N).</li>
<li><strong>Two-pointers:</strong> Use <code>reader</code> and
<code>writer</code> pointers. For an opening bracket, copy it to
<code>s[writer++]</code>. For a closing bracket, decrement
<code>writer</code>. If <code>writer</code> becomes negative or
<code>s[writer]</code> doesn’t match the closing bracket, the string is
invalid. Finally, the string is valid if <code>writer</code> is 0. Time:
O(N), Space: O(1).</li>
</ul>
<h4 id="remove-all-adjacent-duplicates-in-string">Remove All Adjacent
Duplicates In String</h4>
<ul>
<li><em>You are given a string s consisting of lowercase English
letters. A duplicate removal consists of choosing two adjacent and equal
letters and removing them. We repeatedly make duplicate removals on s
until we no longer can. Return the final string after all such duplicate
removals have been made. It can be proven that the answer is
unique.</em></li>
<li><strong>Stack-based:</strong> Use a
<code>std::vector&lt;char&gt;</code> to simulate a stack. Iterate
through the input string character by character. If the vector is not
empty and the current character <code>c</code> is equal to the last
character in the vector (<code>stack.back()</code>), then pop the last
character from the vector. Otherwise, push the current character
<code>c</code> onto the vector. Finally, construct the result string
from the characters remaining in the vector. Time: O(N), Space:
O(N).</li>
<li><strong>Two-pointers:</strong> Use <code>reader</code> and
<code>writer</code> pointers. <code>writer</code> starts at 0.
<code>reader</code> iterates through the string. If
<code>writer &gt; 0</code> and <code>s[reader]</code> is the same as
<code>s[writer - 1]</code>, decrement <code>writer</code>. Otherwise,
copy <code>s[reader]</code> to <code>s[writer++]</code>. Finally, resize
the string to <code>writer</code>. Time: O(N), Space: O(1).</li>
</ul>
<h4 id="removing-stars-from-a-string">Removing Stars from a String</h4>
<ul>
<li><em>You are given a string s, which contains stars </em>. In one
operation, you can: Choose a star in s. Remove the closest non-star
character to its left, as well as remove the star itself. Return the
string after all stars have been removed.*</li>
<li><strong>Stack-based:</strong> Use <code>std::vector</code> as a
stack. Iterate through the string, pushing non-<code>*</code> characters
onto the stack and popping for <code>*</code>. Time: O(N), Space:
O(N).</li>
<li><strong>Two-pointers:</strong> Use <code>reader</code> and
<code>writer</code> pointers. <code>reader</code> iterates through the
string. If <code>s[reader]</code> is not <code>*</code>, copy it to
<code>s[writer++]</code>. If it is <code>*</code>, decrement
<code>writer</code>. Finally, resize the string to <code>writer</code>.
Time: O(N), Space: O(1).</li>
</ul>
<h4 id="simplify-path">Simplify Path</h4>
<ul>
<li><em>Given a string path, which is an absolute path (starting with a
slash ‘/’) to a file or directory in a Unix-style file system, convert
it to the simplified canonical path. In a Unix-style file system, a
period ‘.’ refers to the current directory, a double period ‘..’ refers
to the directory up a level, and multiple consecutive slashes (e.g.,
“//”) are treated as a single slash. For this problem, any other format
of periods (e.g., “…”) are treated as file/directory names. The
canonical path should have the following format: The path starts with a
single slash ‘/’. Any two directories are separated by a single slash
‘/’. The path does not end with a trailing ‘/’. The path only contains
the directories on the path from the root directory to the target file
or directory (i.e., no ‘.’ or ‘..’)</em></li>
<li><strong>Stack with Manual Parsing:</strong> Use a
<code>std::vector&lt;std::string&gt;</code> as a stack. Iterate through
the path character by character to build directory names. When a
<code>/</code> is encountered, it signals the end of a component. This
component is then processed: if it is <code>..</code>, pop an element
from the stack. If it is not empty or <code>.</code>, push the component
onto the stack. After the loop, there might be a final component to
process. Finally, join the elements in the stack with <code>/</code> to
construct the final simplified path, ensuring it starts with a
<code>/</code>. If the stack is empty, the result is simply
<code>/</code>. Time: O(N), Space: O(N).</li>
</ul>
<h4 id="number-of-recent-calls">Number of Recent Calls</h4>
<ul>
<li><em>You have a RecentCounter class which counts the number of recent
requests within a certain time frame. Implement the RecentCounter class:
RecentCounter() Initializes the counter with zero recent requests. int
ping(int t) Adds a new request at time t, where t represents some time
in milliseconds, and returns the number of requests that happened in the
inclusive time range [t - 3000, t]. It is guaranteed that every call to
ping uses a strictly larger value of t than the previous call.</em></li>
<li><strong>Description:</strong> Use a <code>deque</code> to store
timestamps of recent requests. When a new request arrives, remove all
timestamps from the front of the deque that are older than 3000
milliseconds. Then, add the new request’s timestamp to the back and
return the size of the deque.</li>
<li><strong>Time Complexity:</strong> O(W) where W is the window size
(3000 in this case). In the worst case, we might have to remove all
elements from the previous window.</li>
<li><strong>Space Complexity:</strong> O(W) where W is the maximum
number of requests in the 3000ms window.</li>
</ul>
</body>
</html>

<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>chapter_2_sliding_window</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="style.css" />
  <base href="/algo_leetcode/">
</head>
<body>
<h2 id="sliding-window">Sliding Window</h2>
<h3 id="fixed-size-sliding-window">Fixed-size sliding window</h3>
<h4 id="maximum-average-subarray-i">Maximum Average Subarray I</h4>
<ul>
<li><em>You are given an integer array nums consisting of n elements,
and an integer k. Find a contiguous subarray whose length is equal to k
that has the maximum average value and you return this value. Any answer
with a calculation error less than 10-5 will be accepted.</em></li>
<li>Set <code>begin</code> to 0, iterate <code>end</code> over all
elements. On each iteration increase <code>win_sum</code>. If
<code>win_len</code> is <code>k</code>, update <code>max_avg</code>,
decrease <code>win_sum</code> by the <code>begin</code> element, and
move <code>begin</code> forward.</li>
<li>Time complexity: O(n)</li>
<li>Space complexity: O(1)</li>
</ul>
<h4 id="permutation-in-string">Permutation in String</h4>
<ul>
<li><em>Given two strings s1 and s2, return true if s2 contains a
permutation of s1, or false otherwise. In other words, given two strings
s1 and s2, write a function to return true if s2 contains the
permutation of s1 as a substring. This means that the characters in s1
must be present in s2 in the same quantity, but their order can be
different.</em></li>
<li><strong>Description:</strong> Use a sliding window of size
<code>s1.size()</code>. Initialize a character count structure (an array
of size 26 for small alphabets like lowercase English, or a hash map for
larger character sets) with character counts from <code>s1</code>.
Iterate through <code>s2</code> with a sliding window. For each
character entering the window, decrement its count in the structure. For
each character leaving the window, increment its count. Maintain a
<code>zeroCount</code> variable to track how many characters in the
structure have a count of zero. If <code>zeroCount</code> equals the
number of unique characters in <code>s1</code> (or 26 for the array
approach), a permutation is found. The counts can be negative if a
character appears more times in the window (from <code>s2</code>) than
in <code>s1</code>.</li>
<li><strong>Time Complexity:</strong> O(L1 + L2), where L1 is the length
of s1 and L2 is the length of s2.</li>
<li><strong>Space Complexity:</strong> O(1) (constant space for the
array/hash map, as it stores at most 26 characters or unique characters
from s1).</li>
</ul>
<h3 id="variable-size-sliding-window">Variable-size sliding window</h3>
<h4 id="longest-substring-without-repeating-characters">Longest
Substring Without Repeating Characters</h4>
<ul>
<li><em>Given a string s, find the length of the longest substring
without repeating characters.</em></li>
<li><strong>Description:</strong> Use a variable-size sliding window.
Maintain a <code>std::array&lt;char, 256&gt; counts{}</code> to store
character frequencies within the current window. Iterate with
<code>right</code> pointer. For each character <code>s[right]</code>,
increment its count. If <code>counts[s[right]]</code> becomes greater
than 1, indicating a duplicate, shrink the window from the
<code>left</code> by decrementing <code>counts[s[left]]</code> and
incrementing <code>left</code> until the duplicate is removed. After
each <code>right</code> iteration, update
<code>maxLen = max(maxLen, right - left + 1)</code>.</li>
<li><strong>Time Complexity:</strong> O(N), where N is the length of the
string, as each character is visited at most twice (once by
<code>right</code> and once by <code>left</code>).</li>
<li><strong>Space Complexity:</strong> O(1), as the <code>counts</code>
array size is fixed (256 for ASCII characters).</li>
</ul>
<h4 id="minimum-size-subarray-sum">Minimum Size Subarray Sum</h4>
<ul>
<li><em>Given an array of positive integers nums and a positive integer
target, return the minimal length of a subarray whose sum is greater
than or equal to target. If there is no such subarray, return 0
instead.</em></li>
<li>Use a classical sliding window. When the window sum is greater than
or equal to the target, update the minimum length and shrink the window
from the beginning in a loop.</li>
<li>Time complexity: O(n)</li>
<li>Space complexity: O(1)</li>
</ul>
<h4 id="max-consecutive-ones-iii">Max Consecutive Ones III</h4>
<ul>
<li><em>Given a binary array nums and an integer k, return the maximum
number of consecutive 1’s in the array if you can flip at most k
0’s.</em></li>
<li>Sliding window where the window state is the number of flipped
zeros. Iterate <code>end</code> over all elements, and if needed, move
<code>begin</code> in a loop to maintain the window state. Update
<code>max_len</code> at the end of each <code>end</code> iteration.</li>
<li>Time complexity: O(n)</li>
<li>Space complexity: O(1)</li>
</ul>
<h4 id="fruit-into-baskets">Fruit into Baskets</h4>
<ul>
<li><em>You are given an integer array fruits where fruits[i] is the
type of the ith fruit you would pick. You have two baskets, and each
basket can only hold a single type of fruit. There is no limit on the
amount of fruit each basket can hold. You can start at any tree you
want, but you must not skip a tree once you have started. You will
continue picking fruits from trees when you move to the right. Return
the maximum number of fruits you can pick.</em></li>
<li>Use an unordered map to count fruit types in the window. On each
iteration, add the new fruit to the map. If the map size exceeds the
allowed number of baskets, shrink the window from the beginning in a
loop, decrementing fruit counts until a fruit type is removed from the
map. Update the maximum number of fruits with the current window length
on each iteration.</li>
<li>Time complexity: O(n)</li>
<li>Space complexity: O(k) where k is the number of baskets</li>
</ul>
<h4 id="longest-subarray-of-1s-after-deleting-one-element">Longest
Subarray of 1s After Deleting One Element</h4>
<ul>
<li><em>Given a binary array nums, you should delete one element from
it. Return the size of the longest subarray containing only 1’s in the
resulting array.</em></li>
<li>The window state is the number of zeros. On each iteration, update
the state. If needed, shrink the window in a cycle. Update
<code>maxOnes</code> using <code>winLen</code> - 1.</li>
<li>Time complexity: O(n)</li>
<li>Space complexity: O(1)</li>
</ul>
</body>
</html>

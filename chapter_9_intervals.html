<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>chapter_9_intervals</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="style.css" />
  <base href="/algo_leetcode/">
</head>
<body>
<h2 id="intervals">Intervals</h2>
<h4 id="meeting-rooms">Meeting Rooms</h4>
<ul>
<li><strong>Task:</strong> <em>Given an array of meeting time intervals
where intervals[i] = [start, end], determine if a person could attend
all meetings.</em></li>
<li><strong>Task summary:</strong> Check if any meetings in a list of
time intervals overlap.</li>
<li><strong>Solution:</strong> Sort the intervals by their start times.
Then, iterate through the sorted intervals from the second interval. If
the start time of the current meeting is less than the end time of the
previous meeting, it means there is an overlap, and we return
<code>false</code>. If the loop completes without finding any overlaps,
it means no meetings overlap, and we return <code>true</code>.</li>
<li><strong>Time complexity:</strong> O(N log N) due to the sorting
step.</li>
<li><strong>Space complexity:</strong> O(1) if sorting is done
in-place.</li>
</ul>
<h4 id="merge-intervals">Merge Intervals</h4>
<ul>
<li><strong>Task:</strong> <em>Given an array of <code>intervals</code>
where <code>intervals[i] = [starti, endi]</code>, merge all overlapping
intervals, and return an array of the non-overlapping intervals that
cover all the intervals in the input.</em></li>
<li><strong>Task summary:</strong> Merge all overlapping intervals in a
collection.</li>
<li><strong>Solution:</strong> First, sort the input
<code>intervals</code> array by their start times using
<code>std::sort</code>. Then, iterate through the sorted intervals
starting from the second interval (index 1). For each current interval
(<code>intervals[i]</code>) and its previous interval
(<code>intervals[i-1]</code>):
<ul>
<li>If <code>intervals[i].start &lt;= intervals[i-1].end</code> (meaning
they overlap, including cases where
<code>intervals[i].start == intervals[i-1].end</code>):
<ul>
<li>Update the current interval’s start to
<code>intervals[i-1].start</code>.</li>
<li>Update the current interval’s end to
<code>std::max(intervals[i].end, intervals[i-1].end)</code>.</li>
<li>Mark the previous interval as invalid by setting
<code>intervals[i-1].start = -1</code>. After the loop, use
<code>std::erase_if</code> to remove all intervals from the array whose
start time is -1.</li>
</ul></li>
</ul></li>
<li><strong>Time complexity:</strong> O(N log N) due to the initial
sort. The iteration and <code>std::erase_if</code> are O(N).</li>
<li><strong>Space complexity:</strong> O(1) if the modification is done
in-place on the input array.</li>
</ul>
<h4 id="insert-interval">Insert Interval</h4>
<ul>
<li><strong>Task:</strong> <em>You are given an array of non-overlapping
intervals <code>intervals</code> where
<code>intervals[i] = [starti, endi]</code> are sorted by their start
times, and a new interval <code>newInterval = [start, end]</code>.
Insert <code>newInterval</code> into <code>intervals</code> such that
<code>intervals</code> is still sorted in ascending order by
<code>starti</code> and <code>intervals</code> still does not have any
overlapping intervals (merge overlapping intervals if
necessary).</em></li>
<li><strong>Task summary:</strong> Insert a new interval into a sorted
list of non-overlapping intervals, merging if necessary.</li>
<li><strong>Solution:</strong> Initialize an empty <code>result</code>
vector and an integer <code>i = 0</code> to iterate through the
<code>intervals</code> array.
<ol type="1">
<li><strong>Before overlap:</strong> While <code>i</code> is less than
the size of <code>intervals</code> and
<code>intervals[i][1] &lt; newInterval[0]</code>, add
<code>intervals[i]</code> to <code>result</code> and increment
<code>i</code>.</li>
<li><strong>Overlap:</strong> While <code>i</code> is less than the size
of <code>intervals</code> and
<code>intervals[i][0] &lt;= newInterval[1]</code>, merge
<code>intervals[i]</code> into <code>newInterval</code>. Update
<code>newInterval[0] = std::min(newInterval[0], intervals[i][0])</code>
and
<code>newInterval[1] = std::max(newInterval[1], intervals[i][1])</code>.
Increment <code>i</code>.</li>
<li><strong>Add merged/new interval:</strong> Add the (potentially
extended) <code>newInterval</code> to <code>result</code>.</li>
<li><strong>After overlap:</strong> While <code>i</code> is less than
the size of <code>intervals</code>, add <code>intervals[i]</code> to
<code>result</code> and increment <code>i</code>.</li>
</ol></li>
<li><strong>Time complexity:</strong> O(N), as we iterate through the
intervals once.</li>
<li><strong>Space complexity:</strong> O(N) for the <code>result</code>
vector.</li>
</ul>
<h4 id="meeting-rooms-ii">Meeting Rooms II</h4>
<ul>
<li><strong>Task:</strong> <em>Given an array of meeting time intervals
<code>intervals</code> where <code>intervals[i] = [start, end]</code>,
return the minimum number of conference rooms required.</em></li>
<li><strong>Task summary:</strong> Find the minimum number of conference
rooms needed to accommodate all meetings.</li>
<li><strong>Solution:</strong> First, sort the input
<code>intervals</code> array by their start times. Initialize a min-heap
(e.g.,
<code>std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt;</code>)
to store the ending times of meetings currently occupying rooms. Iterate
through the sorted meetings. For each meeting:
<ul>
<li>If the heap is not empty and the earliest ending meeting in the heap
(<code>rooms.top()</code>) finishes at or before the current meeting
starts (<code>rooms.top() &lt;= meeting.start</code>), it means that
room can be reused. Pop the element from the heap.</li>
<li>Always push the current meeting’s ending time
(<code>meeting.end</code>) into the heap. The final size of the heap
will be the minimum number of rooms required.</li>
</ul></li>
<li><strong>Time complexity:</strong> O(N log N) due to sorting and heap
operations (N pushes/pops, each O(log N)).</li>
<li><strong>Space complexity:</strong> O(N) in the worst case, as the
heap could store all meeting end times if all meetings overlap.</li>
</ul>
</body>
</html>

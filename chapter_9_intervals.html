<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>chapter_9_intervals</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="style.css" />
  <base href="/algo_leetcode/">
</head>
<body>
<h2 id="intervals">Intervals</h2>
<h4 id="meeting-rooms">Meeting Rooms</h4>
<ul>
<li><strong>Task:</strong> <em>Given an array of meeting time intervals
where intervals[i] = [start, end], determine if a person could attend
all meetings.</em></li>
<li><strong>Task summary:</strong> Check if any meetings in a list of
time intervals overlap.</li>
<li><strong>Solution:</strong> Sort the intervals by their start times.
Then, iterate through the sorted intervals from the second interval. If
the start time of the current meeting is less than the end time of the
previous meeting, it means there is an overlap, and we return
<code>false</code>. If the loop completes without finding any overlaps,
it means no meetings overlap, and we return <code>true</code>.</li>
<li><strong>Time complexity:</strong> O(N log N) due to the sorting
step.</li>
<li><strong>Space complexity:</strong> O(1) if sorting is done
in-place.</li>
</ul>
</body>
</html>

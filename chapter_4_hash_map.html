<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>chapter_4_hash_map</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="style.css" />
  <base href="/algo_leetcode/">
</head>
<body>
<h2 id="hash-map">Hash Map</h2>
<h4 id="implement-lru-cache">Implement LRU Cache</h4>
<ul>
<li><em>Design a data structure that follows the constraints of a Least
Recently Used (LRU) cache. Implement the LRUCache class: LRUCache(int
capacity) initializes the LRU cache with the given positive capacity.
int get(int key) Returns the value of the key if the key exists,
otherwise return -1. void put(int key, int value) Update the value of
the key if the key exists. Otherwise, add the key-value pair to the
cache. If the number of keys exceeds the capacity from this operation,
evict the least recently used key. The functions get and put must each
run in O(1) average time complexity.</em></li>
<li>Use <code>std::list&lt;int&gt;</code> to maintain the key access
order (most recently used at the front). Use
<code>std::unordered_map&lt;int, std::tuple&lt;int, std::list&lt;int&gt;::iterator&gt;&gt;</code>
to store keys, their corresponding values, and an iterator to their
position in the <code>std::list</code>. On access, move the key to the
front of the list. On insertion when capacity is full, remove the least
recently used item (back of the list) and its entry from the map.</li>
<li>Time complexity: <code>get</code> and <code>put</code> are
O(1).</li>
<li>Space complexity: O(capacity)</li>
</ul>
<h4 id="strings-making-anagrams-hackerrank">Strings: Making Anagrams
(HackerRank)</h4>
<ul>
<li><em>Given two strings, a and b, that may or may not be of the same
length, determine the minimum number of character deletions required to
make a and b anagrams. Any characters can be deleted from either of the
strings. Anagrams are strings that contain the same exact letters with
the same exact frequencies.</em></li>
<li>Use two hash maps, <code>dict1</code> and <code>dict2</code>.
Iterate through <code>s1</code>: for each character <code>c</code>,
<code>dict1[c]++</code> and <code>dict2[c] += 0</code>. Then, iterate
through <code>s2</code>: for each character <code>c</code>,
<code>dict2[c]++</code> and <code>dict1[c] += 0</code>. After these
operations, both <code>dict1</code> and <code>dict2</code> will contain
all unique characters present in either string, but counter for only one
correspndent string. Then iterate dict1. In each iteration get count1
and count2 for character. To equalize occurrences in both strings, we
need to delete <code>abs(dict1[c] - dict2[c])</code> for each character
<code>c</code>. Sum these absolute differences to get the total
deletions required.</li>
<li>Time complexity: O(n + m)</li>
<li>Space complexity: O(1)</li>
</ul>
<h4 id="two-sum">Two Sum</h4>
<ul>
<li><em>Given an array of integers nums and an integer target, return
indices of the two numbers such that they add up to target. You may
assume that each input would have exactly one solution, and you may not
use the same element twice. You can return the answer in any
order.</em></li>
<li>Use ‘visited’ hash map</li>
<li>Time complexity: O(n)</li>
<li>Space complexity: O(n)</li>
</ul>
</body>
</html>

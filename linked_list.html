<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>linked_list</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="style.css" />
  <base href="/algo_leetcode/">
</head>
<body>
<h2 id="linked-list">Linked list</h2>
<h3 id="design-linked-list">Design Linked List</h3>
<ul>
<li>Implement a singly linked list using a <code>dummyHead</code> and a
<code>size</code> counter. The <code>dummyHead</code> simplifies edge
cases. Key methods <code>addAtHead</code> and <code>addAtTail</code> can
be efficiently implemented by calling the more general
<code>addAtIndex(0, val)</code> and <code>addAtIndex(size, val)</code>
respectively.</li>
<li>Time complexity: <code>get</code>, <code>addAtIndex</code>,
<code>deleteAtIndex</code> are O(n). <code>addAtHead</code> is O(1),
<code>addAtTail</code> is O(n).</li>
<li>Space complexity: O(n) to store the list elements.</li>
</ul>
<h3 id="middle-of-the-linked-list">Middle of the Linked List</h3>
<ul>
<li>Use slow and fast pointers. Move slow by one step and fast by two
(<code>fast = fast.next.next</code>). When fast reaches the end, slow is
at the middle.</li>
<li>Time complexity: O(n)</li>
<li>Space complexity: O(1)</li>
</ul>
<h3 id="delete-the-middle-of-the-linked-list">Delete the Middle of the
Linked List</h3>
<ul>
<li>Use slow and fast pointers, keeping a <code>prevSlow</code> pointer.
When <code>fast</code> reaches the end, <code>slow</code> is the middle.
To delete the middle node, set <code>prevSlow.next = slow.next</code>.
Handle the edge case where the list has only one node, in which case
<code>prevSlow</code> would be null.</li>
<li>Time complexity: O(n)</li>
<li>Space complexity: O(1)</li>
</ul>
<h3 id="reverse-linked-list">Reverse Linked List</h3>
<ul>
<li>Initialize <code>curr = head</code> and <code>prev = null</code>.
Iterate through the list, at each step, store <code>curr.next</code> in
a temporary variable, set <code>curr.next = prev</code>, then update
<code>prev = curr</code> and <code>curr = temp</code>. Return
<code>prev</code> at the end.</li>
<li>Time complexity: O(n)</li>
<li>Space complexity: O(1)</li>
</ul>
<h3 id="palindrome-linked-list">Palindrome Linked List</h3>
<ul>
<li>First, implement <code>findMiddle(head)</code> using slow and fast
pointers. Then, implement <code>reverseList(head)</code> (as described
above). Use these to find the middle of the original list and reverse
its second half. Finally, compare the first half of the original list
with the reversed second half. Iterate only as long as the reversed
second half has elements, as the first half might be longer for
odd-length lists.</li>
<li>Time complexity: O(n)</li>
<li>Space complexity: O(1)</li>
</ul>
<h3 id="remove-duplicates-from-sorted-list">Remove Duplicates from
Sorted List</h3>
<ul>
<li>Iterate with a <code>curr</code> pointer while <code>curr</code> and
<code>curr.next</code> exist. If <code>curr.val == curr.next.val</code>,
set <code>curr.next = curr.next.next</code> (skipping the duplicate) and
do not advance <code>curr</code>. Otherwise, move <code>curr</code>
forward (<code>curr = curr.next</code>).</li>
<li>Time complexity: O(n)</li>
<li>Space complexity: O(1)</li>
</ul>
</body>
</html>
